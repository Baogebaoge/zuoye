#### 网页的组成(3部分)
* 结构层(html)
* 表现层(css)
* 行为层(JS)

#### 程序？
炒菜的过程是流程，把炒菜的过程写成菜谱是程序，记录炒菜的过程就是编程。

##### 流程 
##### 需求
##### 程序
##### 编程

####程序？
	为了实现某个功能或者某个目的，通过计算机语言写的指令序列的集合。

#### JavaScript Java
* #### 公司：java-sun  JS-网景公司
* 语言：java是强类型的语言  JS是弱类型的语言
* java是纯面向对象的(封装、继承、多态)  
  JS是基于对象(内置对象：日期，数组...)
* 执行：java是编译类型的；JS是解释型的

#### JS作用
* 实现动效
* 数据验证
* 操作html/css
* 制作游戏()
* 单页面应用(谷歌在线的word、excel等编辑器；各大平台的云)
* 服务器端的应用(node.js)
* cookie

##### JS是什么？
	JS是一个脚本语言(可以直接在浏览器中解析执行，无需编译)。
	特点：JS是基于对象和事件驱动的解释型的松散型语言。
	* 基于对象
	* 事件驱动：对浏览器和用户的行为进行响应
	* 解释型：
	* 松散型(弱类型)：

#### JS语言
#### 1、 如何执行？

#### 2、 html如何引入JS？

* 引入外部文件   

  ```
  <script src=""></script>
  ```

  ​

  **注意** ：引入外部文件的时候，不能在标签中间写入内容

* 嵌入式   

  ```
  <script></script>
  ```

  ​

* 在超链接或者重定向中写入

  * 超链接   

    ```
    <a href="javascript:alert(1)">超链接</a>
    ```

    超链接的表现形式(4种)：

    ```
    <!-- 普通链接 -->
    <a href="http://www.sxuek.com">山西优逸客</a>

    <!-- 写入js代码，会屏蔽href属性 -->
    <a href="javascript:alert(1)">超链接</a>
    <a href="javascript:void(0)">超链接</a>

    <!-- 资源下载，默认只能是压缩过的文件 -->
    <a href="1.zip"></a>

    <!-- 空链接，实现的是返回页面顶部 -->
    <a href=""></a>
    ```

  * 重定向中

     <form action="javascript:alert(1)" method="">
     		<input type="submit">
     	</form>

* 在事件之后调用

  * ```
    <div onclick="alert(1)">点击我</div>
    ```

**注意：** 多个script块之间会相互影响

#### 3、 如何输出？

```
	1、alert();  
         在页面中弹出一个框。
		注意：alert会阻止后面代码的执行
	2、console.log();
		将数据内容输出至控制台
	3、document.write()
		将数据内容输出至页面中
		注意：识别标签和行内样式
	4、confirm()
		在页面中弹出一个带确定和取消按钮的弹出框
	5、prompt('请输入你的姓名');
		页面中弹出一个带提示信息和输入框的弹出框
```
#### 4、 变量

##### 一、命名规范：

> 1、变量名必须以字母、下划线 _ 或 \$ 开头，后面部分可以跟任意的字母、数字、_ 、或 $
>
> 2、不能使用关键字(JS自定义的 var)或者是保留字(为以后扩展用)命名
>
> 3、JavaScript有自己的命名习惯
> * 驼峰命名法：getElementById
> * 首字母大写法：Object
>
> 4、变量名区分大小写
>
> 5、命名一定要有意义，提高代码可读性

##### 二、什么是变量？

变量就是保存数据的容器。	

内存就是一个盒子，每次声明一个变量，它都会在内存中开辟一段空间进行保存。保存起来后，当我们需要用的时候会从内存中获取相应的数据。如果浏览器关闭，内存会释放空间，方便下次使用。

##### 三、变量声明(通过关键字)	

* var 
* let (es6)
  * let的用法类似于var
  * let不存在变量提升现象
  * let不能重新声明，报错该变量已经存在
* const (es6)
  * const声明的是一个常量
  * const只能声明的同时进行赋值
  * const也不存在变量提升现象
  * const不能重新声明，报错该变量已存在

##### 四、变量的赋值情况

	1. 声明变量的同时进行赋值
	2. 声明之后赋值
	3. 声明多个变量并同时进行赋值
		  注意：多个变量之间用逗号隔开
	4.  声明多个变量，之后赋值
##### 五、注意：

	1. 变量声明之前进行调用，会返回undefined(未赋值)。【变量提升现象】
	2. 不通过关键字声明的变量，但是赋值了，它会返回对应的值(全局变量)
	3. 不通过关键字声明的变量，但是没有赋值，会报错。
	4. 对变量重新赋值，会发生覆盖。
	1. 对变量重新声明赋值，会发生覆盖。
##### 六、数据类型

>  能够表达或者操作值的类型，称为数据类型

1. 为何要划分数据类型？

  需求
  在内存中存储的位置不一样
1. 数据类型（两大类）

   * 初始类型(存放在栈区，内存比较小，访问速度快)

     ```
     * undefined
     可能的情况：声明变量并未赋值，返回undefined;
     声明变量之前进行访问，返回undefined。
     返回的值：undefined
     ```

     ```
     * null (空，占位符)
     可能的值：null
     返回的值：null
     返回值的类型：object
     ```


     ```
     * number(数值类型)
     可能的值：整型、浮点型、二进制、十进制、八进制、十六进制、科学			计数法(最大值，最小值)
     返回的值：对应的数值
     返回值的类型：number
     ```
    
     ```
     * string (字符串类型)
     可能的值：通过引号引起来的
     返回的值：对应的字符串
     返回值的类型：string
     ```
    
     ```
     * boolean (布尔类型)
     可能的值：true  false
     返回的值：true  false
     返回值的类型：boolean
     ```
    
     ```
     * symbol (es6)
     ```

* 引用类型（存放在堆区，内存较大，访问速度慢）

     ```
     object(数组，函数...)
     ```

### 5、 运算符

##### 1.  算术运算符

（+、-、*、/、%、++、--）

```
+: 
  * 进行加法运算
    * 如果两个操作数都是number，最终得到number的值
    * 如果其中一个操作数是undefined，最终得到NaN(not a number，是number类型的一个状态)
    * 如果其中一个操作数是null，最终得到number的值
    * 如果其中一个操作数是boolean，会转换成对应的值进行计算

  * 字符串连接
  	* 如果操作数有一个是string

- :
  * 如果两个操作数都是number，最终得到number的值
  * 如果其中一个操作数是undefined，最终得到NaN
  * 如果其中一个操作数是null，最终得到number的值
  * 如果其中一个操作数是boolean，会转换成对应的值进行计算
  * 如果其中一个操作数是string
    * 数值 ： 隐式转换
    * 字母 ：NaN
  * 如果两个操作数都是string，得到NaN	
```

##### 2. 关系运算符 

（>、<、>=、<=、==、===（全等）、！=、！==（不全等））

```
(1)、操作数都是数字,正数大于负数

(2)、两个操作数都是字符串，按照ASCII码表进行比较,如果首字符大则后面不需要比较;如果首字符大小一样,则比较第二个字符的ASCII码值，依次类推。

(3)、数字与布尔值进行比较,隐式转换,true-1  false-0

(4)、数字和字符串进行比较,首先把字符串试图转换为数字,如果转换成功则进行比较,如果转换不成功，返回false

(5)、 alert(0==undefined)	    false
      alert(0==null)			 false
      alert(1==true)			 true
      alert(1===true)			 false
      alert(1=="true")			 false
      alert(undefined==null)	 false
```

##### 3. 赋值运算符

 (= += -= *= /= %=)

##### 4. 逻辑运算符

(&& 与      || 或     !非)

数字0、false、undefined、null、NaN、空字符串都为false

* 逻辑与 &&   同真为真   

  >  如果第一个操作数为假，发生短路原则，对第二个数不会进行操作，并返回假值

| num1  | num2  | result | 结果   |
| ----- | ----- | ------ | ---- |
| true  | true  | true   | num2 |
| true  | false | false  | num2 |
| false | true  | false  | num1 |
| false | false | false  | num1 |

* 逻辑或  ||  同假为假

  > 若果第一个操作数为真，发生短路原则，对第二个数不会进行操作，并返回真值

| num1  | num2  | result | 结果   |
| ----- | ----- | ------ | ---- |
| true  | true  | true   | num1 |
| true  | false | true   | num1 |
| false | true  | true   | num2 |
| false | false | false  | num2 |

##### 5.其它运算符

	1、一元运算符
	  typeof
	  ++ --
	  +(正号) -(负号)
	  delete (删除一个对象)
	2、三元运算符
		条件表达式?为真的值:为假的值
##### 6. 特殊运算符 ()

	作用：提高优先级

##### 7. 模板字符串 (es6)

	作用：方便引入变量
	模板字符串要用反引号引起来，如果需要引入变量通过${变量名}
	eg：console.log(`这是num1 -- ${num1}和num2 -- ${num2}的和${sum}`);
##### 8. 流程控制

1.    **流程**

      > 程序代码的执行顺序。

      注意：JS的执行是根据浏览器的解析从上到下，一条语句一条语句的执行，有且只有这一种方式。

2.    流程控制

      > 通过规定的语句让程序代码有条件的按照一定的方式执行。

3.    **表达式**

      > 表达式一般由运算符和操作数构成，且有一定的值(已经有值或者即将赋值)

4.    **语句**

                        	以;为标识的为一条语句。
      * 声明语句 （声明一个变量、数组...）
          * 赋值语句 （对变量进行赋值）
            * 控制语句  if语句，switch语句，for语句等等
            * 表达式语句  eg:console.log(a); 函数调用

5.    **三大流程控制**

                        1、顺序结构

      >  是程序中最基本的流程控制。默认从上到下，一条语句一条语句执行。

      2、选择结构	

      *  分支结构

                ​	

                ​```
                if(条件){执行的语句}
                
                if(){}else{}
                
                if(){}else if(){}else{}
                
                注意：条件可以是表达式也可以是任何数据类型
                
                ​```

         * 条件结构	

        > 条件或情况有限，多个选择进行相应的匹配

        ```
        switch(表达式){
          case 条件1:条件1成立执行的语句;
          break;
          case 条件2:条件2成立执行的语句;
          break;
          ...
          default:条件都不满足执行的语句;
        }
        注意：switch语句中不会对数据类型进行隐式转换
        ```

      3、循环结构

      在条件满足的情况下，重复执行某一段代码

      ```
      1、for(条件初始化;终止条件;步进值){	
             循环体
      }
      执行流程：条件初始化-----判断条件是否成立----条件成立执行循环体-----步进值----重复执行二、三、四步-----直到条件不成立，退出循环，执行循环之后的代码。

       2、while语句
       * while（条件表达式）{要执行的语句;} 
       3、do while语句
       do{

        }while()
       总结：
       while和do while的区别：
       * while：满足条件才执行循环体
       * do while：先执行一次循环体，在进行判断。

       for和while
        * 循环次数确定时用for
       * 循环次数不确定时用while
      ```

      注意：循环需要一定的次数，否则就是死循环，死循环在程序中是不建议的

### 6、数组

​	一、数组

    变量：存储数据的容器
    数组：存储一组或者一系列相关数据的集合
  二、优势
    * 方便对数据进行管理
    * 可以保存大批量的数据
  三、创建方式
    1、json格式
      var arr = [];
    2、通过实例化对象的方式
      var arr = new Array();
  四、赋值情况
    1、声明的同时赋值
      var arr = [34,65,577,978,'sas','er'];
    2、声明之后赋值
      var arr1 = [];
      arr1[0] = 34;
      arr1[1] = 65;
  五、对数组的访问
    以下标的形式进行访问
    * length属性：统计数组的长度
    * 访问数组的第一个元素：arr[0];
    * 访问数组的最后一个元素：arr[arr.length-1];
  六、对数组的遍历
    * for
      for(初始化值；条件表达式；步操作){
        执行的语句
      }
    * for in（es6）：for(var i in arr.length){arr[i]*=2;}【一般用于数组和对象的遍历】
      for(变量 in 对象){
    
      }
      for in 最终遍历出来的是对象的属性

  注意：
    * 数组默认值是空的【变量默认值是undefined】
    * 数组的程度是可变化的
    * 数组可以保存任何类型的数据
    * 数组下标是从0开始
二维数组：每个数组元素的值对应的又是一个数组。

	二维数组的访问方式：
		通过双下标
	
	二维数组的遍历：双层for循环


	三、浅拷贝和深拷贝
		浅拷贝：传地址,会改变。
			指向的是赋值对象的引用。
		深拷贝：传值,不会改变。
			指向的是赋值对象所有引用对象的引用。（所有引用对象的全部赋值）

### 7、函数

一、函数

		函数就是将能够实现某一特定功能的代码块封装起来，方便重复调用。
	二、特点
		程序会更加简洁，维护起来会更容易。
	三、函数声明（3种方式）
		1、通过关键字：function 函数名([参数1,参数2,……]){函数体}
		2、通过自面量的方式：var 变量名 = function([参数1,参数2,……]){函数体}
		3、通过实例化对象的方式：var 变量名 = new Function();
	四、函数的调用
		1、函数名/变量名 + ()；
		2、函数自调用：
			注意：函数自调用的时候，无论之前写的什么，都必须加分号
		3、在事件之后调用：
			只需要写函数名
	五：注意
		* 函数名重复会发生覆盖。
		* 通过关键字声明的函数，可以在声明之前进行访问；字面量声明的函数只有在解析到它的时候，才会进行赋值。
		* 代码是从上到下一条语句一条语句解析执行的，多个script块之间由于解释环境一样，它们之间是相互影响，调用不同块之间函数需要注意一定要先声明在调用。
	六、参数：动态改变函数体内对应的类型与值，使统一函数体呈现不同改变。
		形参：声明函数时()里传的是参数。
			* 实现实参
		实参：调用函数时()里传的是参数。
			* 传递给形参
	七、有关参数的个数
		* 实参和形参一一对应
		* 实参个数小于形参：多余的形参返回undefined
		* 实参个数大于形参：只返回形参相对应的值
	八、多余实参的接收
		1、reset参数
			reset接收剩余参数的时候，作为一个数组进行处理
			注意：...reset是运算符
			例如：function al(num,num1,...reset){
					console.log(num,num1,reset);
			}
		2、arguments对象
			当我们创建一个函数时，默认会创建一个arguments对象。
			在arguments对象身上，保存了所有参数的信息。
	九、默认参数
		1、直接在形参后边进行设置
			注意：默认参数位置一定放在最后。
		2、通过三元运算符
			条件表达式？为真的值：为假的值;
		3、逻辑或 || 
	十、函数返回值
		return
		* 在函数调用的地方，返回一个值。
		  注意：如果return后面没有值，返回undefined。
		        return只能返回一个值，如果在return后边跟多个值，会发生覆盖，最终返回最后一个值;
		        在return里面可以有多条语句，但它只执行一条。
		* 终止函数执行，return之后的语句都将不在执行。
	十一、作用域
		环境：
			宿主环境：浏览器
			执行环境：决定了变量和函数的一个访问权限；
				全局环境：整个页面
				函数环境：局部的环境
	
		作用域：有关变量和函数的访问范围。
	
		作用域分为全局作用域和局部作用域。
		全局作用域：在任何地方都可以访问的变量。
			* 在函数之外通过var声明的变量
			* 没有通过关键字声明的变量并且同时赋值
			* window对象，window.name；window.top
		局部作用域：在规定的代码块内能够访问的变量。
		
		块级作用域{}：es6 if switch {function} for
	
		作用域链：作用域链的存在造成了闭包函数的产生。
	
		闭包函数：函数中存在作用域链，函数中的变量全部保存在作用域链中，这样的特性，我们成为闭包。
				(在函数里面在嵌套一个函数，当我们调用这个函数时，就形成了闭包。)
		闭包函数的作用：
				* 保存局部变量；
				* 在函数外部访问局部变量；
		十三、回调函数
			1、把一个函数的指针(直接写函数名)做为参数传递给另一个函数，这个函数就叫回调函数。
			2、传参方式：
				* 通过函数的指针
				* 把整个函数传进去
		十四、递归函数
			在函数内部直接调用自己或者间接调用自身。
			注意：如果逻辑处理不当，就会造成无限递归，从而引起堆栈溢出，且每个
			
			阶乘：n! = n * (n-1)!
		
		十五、模拟函数重载
			函数重载
			* 同一个函数因为传入的参数的类型或个数不同，可以对应多个函数的实现，而且每种实现对应一个函数体。
			* 重载函数常用来实现功能类似而所处理的数据类型不同的问题。
		
		十六、预解析顺序
			1、按照<script></script>块来解析，有多个<script></script>对时，按块解析，先解释第一个<script></script>中的代码
			2、按环境来解析
			3、遇到关键字var和function时（即以关键字创建的函数），提前解析到内存中(相对应的环境里)。即可在声明前调用
			4、若还有<script></script>，再按照上面的顺序进行解析
### 8、对象

​    面向过程：按照流程一步一步进行操作

	面向对象：不管你中间环节具体实现，只要结果。

	一、对象：一切皆对象。
		 对象就是指人们所能接触到的所有事物，有抽象的也有具体的。
	
		对象是属性和行为的集合。
			属性：描述对象特征的数据
			行为：操作对象方法的数据
	
		类：具有相同属性和行为的对象的抽象。
			类是对象的抽象；
			对象是类的实例化；
	
	二、声明一个对象：
		1、实例化
		2、字面量
		3、构造函数
	
	三、添加属性、方法
		属性：对象.属性名 = 属性值
			  对象['属性名'] = 属性值
	
		方法：对象.方法名 = function(){}
			  对象['方法名'] = function(){}
	
	四、访问属性、方法
		属性：对象.属性名
		      对象['属性名']
	
		方法：对象.方法名
		      对象['方法名']
	五、删除属性、方法
			delete
	
	六、清空对象
			null
	
	七、for in
			在对象里面 i 对应 属性名/方法名
					   对象名[i] 对应 属性值/方法
			数组 i  对应 下标
	 				   对象名[i] 对应 数组的元素
	 				   
	 八、对象封装：
	    将对象的所有组成部分全部组合起来，并对部分细节进行隐蔽，使其受到保护，只留下和外界的接口。
	    一、工厂函数：不推荐。 方便维护，节省内存，但是代码不规范。
	    二、构造函数：造成内存的浪费。
	    三、原型：数据保存在代码块里面。
	    四、构造函数结合原型：
	        1、构造函数中一般放属性；
	        2、原型中一般放方法。
	
	  九、原型：
			 原型也是一个对象。在js中，每一个对象都会继承另一个对象所有的属性和方法。被继承的对象就叫原型。
	1、对象：[[prototype]]
	    [[prototype]]是对象内部的一个属性，但是我们不能直接访问。FF和Chrome提供了'proto'访问器，ECM提供了Object.getPrototype(object)访问器。
	    指向该对象的原型
	
	2、函数：prototype 保存的是该函数的原型对象。
	    当一个函数做为构造函数来使用时，会把该函数的prototype属性做为原型值赋值给所有通过该构造函数实例化的函数的原型。
	
	3、原型对象：constructor  指向的是实例的构造函数。
	
	函数对象和原型对象通过prototype和constructor实现相互关联。
	
	通过prototype可以实现代码共享，实现继承。	 




### 9、内置顶层函数

	内置：ECMAScript
	顶层：页面中任何地方都可以调用
	
	* escape();对字符串进行编码
	  对非字母、数字、特殊标点符号(@ + - . / * 。)的字符串进行编码，最终得到十六进制的转义序列.也就是机器不识别的编码方式编译成机器可以识别的。
	* unescape(str)；对编码的字符串解码
	
	有关数据类型转换
	* number()；将任何数据类型转换为数值类型
	  如果是布尔值，true为1，false为0；
	  如果是数值，转换为本身，会将无意义的后导零与前导零去掉；
	  如果为null，转换为0；
	  如果为undefined，转换为NaN not a number；
	  如果是字符串：
	  	如果字符串中只有数字，则转换为数字(10进制)会忽略前导0和后导0；
	  	如果是规范的浮点数，则转换为浮点数会忽略前导0和后导0；
	  	如果为空字符串或者为空，则转换为0；
	  	如果是其他值，转换为NaN。
	* parselnt();将任何数据类型转换为整数。
		如果一个字符串中只包含数字，转换为十进制数；
		在字符串里面 如果有多个空格，会先找到第一个非空格的值进行转换，直到非数值时结束；
		【如果第一个值不是以数字、空格开头的，一定转换为NaN；】
		有两个参数时，第一个参数表示要转换的值，第二个参数表示几进制，返回的值是一个十进制的数字：
		注意：第一个参数从最高位开始计算，只要有一位数可以识别为第二个参数传入的进制，则可以实现转化；
		注意：第二个参数可以传入的值的范围 2-36.
	
	* parseFloat();将任何数据类型转换为浮点数并返回
		只有一个点起作用，其它无效；
		如果字符串是一个有效的整数，他返回的是整数，不会返回浮点数。
		【如果第一个值不是以数字、空格开头的，一定转换为NaN；】
	* String();将任何数据类型转化为字符串
		如果是null，undefined，转换为字符串“null”“undefined”；
		如果是数值类型，转换为本身的字符串，123转换为“123”；
		如果是布尔类型，true为“true” false为“false”。
	* Boolean();把任何数据类型转化为布尔型
		转换为假：“”(空字符串)，null，undefined，0，false，NaN；
		其他都为真。
	* isNaN();
		判断一个数据能否转换为数值；
		如果能转换成数值返回值，不能返回为真。
	* eval();
		将符合js语法规范的字符串转换为JavaScript命令执行(必须在一行)
	* tostring();
		将对象以字符串的方式来表示，都是通过对象的方式来调用的
			格式：对象.toString();
		* 数组 分割的字符串
		* 布尔
		* 字符串(还是本身)
		* 数值类型
		* null与undefined没有tostring()方法。